const React = require('react');
const { ViewPropTypes } = ReactNative = require('react-native');
const PropTypes = require('prop-types');
const createReactClass = require('create-react-class');
import * as theme from './../../Theme';
import * as Animatable from 'react-native-animatable';
import MyText from './../../components/MyText/MyText';
import Collapsible from '../../components/Collapsible/Collapsible';
import * as api from './../../api/data_nba_endpoints';
import { BoxShadow } from 'react-native-shadow';
import {
    Placeholder,
    PlaceholderMedia,
    PlaceholderLine,
    Fade
} from "rn-placeholder";
import reactotron from 'reactotron-react-native';
const {
  View,
  Animated,
  StyleSheet,
  ScrollView,
  Text,
  Platform,
  Dimensions,
  Image
} = ReactNative;
const Button = require('./Button');

const WINDOW_WIDTH = Dimensions.get('window').width;

const ScrollableTabBar = createReactClass({
  propTypes: {
    goToPage: PropTypes.func,
    activeTab: PropTypes.number,
    tabs: PropTypes.array,
    backgroundColor: PropTypes.string,
    activeTextColor: PropTypes.string,
    inactiveTextColor: PropTypes.string,
    scrollOffset: PropTypes.number,
    style: ViewPropTypes.style,
    tabStyle: ViewPropTypes.style,
    tabsContainerStyle: ViewPropTypes.style,
    textStyle: Text.propTypes.style,
    renderTab: PropTypes.func,
    underlineStyle: ViewPropTypes.style,
    onScroll: PropTypes.func,
    updateHeight: PropTypes.func,
  },

  getDefaultProps() {
    return {
      scrollOffset: 52,
      activeTextColor: 'navy',
      inactiveTextColor: 'black',
      backgroundColor: null,
      style: {},
      tabStyle: {},
      tabsContainerStyle: {},
      underlineStyle: {},
    };
  },

  getInitialState() {
    this._tabsMeasurements = [];
    return {
      _leftTabUnderline: new Animated.Value(0),
      _widthTabUnderline: new Animated.Value(0),
      _containerWidth: null,
    };
  },

  componentDidMount() {
    this.props.scrollValue.addListener(this.updateView);
  },

  updateView(offset) {
    const position = Math.floor(offset.value);
    const pageOffset = offset.value % 1;
    const tabCount = this.props.tabs.length;
    const lastTabPosition = tabCount - 1;

    if (tabCount === 0 || offset.value < 0 || offset.value > lastTabPosition) {
      return;
    }

    if (this.necessarilyMeasurementsCompleted(position, position === lastTabPosition)) {
      this.updateTabPanel(position, pageOffset);
      this.updateTabUnderline(position, pageOffset, tabCount);
    }
  },

  necessarilyMeasurementsCompleted(position, isLastTab) {
    return this._tabsMeasurements[position] &&
      (isLastTab || this._tabsMeasurements[position + 1]) &&
      this._tabContainerMeasurements &&
      this._containerMeasurements;
  },

  updateTabPanel(position, pageOffset) {
    const containerWidth = this._containerMeasurements.width;
    const tabWidth = this._tabsMeasurements[position].width;
    const nextTabMeasurements = this._tabsMeasurements[position + 1];
    const nextTabWidth = nextTabMeasurements && nextTabMeasurements.width || 0;
    const tabOffset = this._tabsMeasurements[position].left;
    const absolutePageOffset = pageOffset * tabWidth;
    let newScrollX = tabOffset + absolutePageOffset;

    // center tab and smooth tab change (for when tabWidth changes a lot between two tabs)
    newScrollX -= (containerWidth - (1 - pageOffset) * tabWidth - pageOffset * nextTabWidth) / 2;
    newScrollX = newScrollX >= 0 ? newScrollX : 0;

    if (Platform.OS === 'android') {
      this._scrollView.scrollTo({x: newScrollX, y: 0, animated: false, });
    } else {
      const rightBoundScroll = this._tabContainerMeasurements.width - (this._containerMeasurements.width);
      newScrollX = newScrollX > rightBoundScroll ? rightBoundScroll : newScrollX;
      this._scrollView.scrollTo({x: newScrollX, y: 0, animated: false, });
    }

  },

  updateTabUnderline(position, pageOffset, tabCount) {
    const lineLeft = this._tabsMeasurements[position].left;
    const lineRight = this._tabsMeasurements[position].right;

    if (position < tabCount - 1) {
      const nextTabLeft = this._tabsMeasurements[position + 1].left;
      const nextTabRight = this._tabsMeasurements[position + 1].right;

      const newLineLeft = (pageOffset * nextTabLeft + (1 - pageOffset) * lineLeft);
      const newLineRight = (pageOffset * nextTabRight + (1 - pageOffset) * lineRight);

      this.state._leftTabUnderline.setValue(newLineLeft);
      this.state._widthTabUnderline.setValue(newLineRight - newLineLeft);
    } else {
      this.state._leftTabUnderline.setValue(lineLeft);
      this.state._widthTabUnderline.setValue(lineRight - lineLeft);
    }
  },

  renderTab(name, page, isTabActive, onPressHandler, onLayoutHandler) {
    const { activeTextColor, inactiveTextColor, textStyle, } = this.props;
    const textColor = isTabActive ? activeTextColor : inactiveTextColor;
    // const fontWeight = isTabActive ? 'bold' : 'normal';
    const fontFamily = isTabActive ? 'SF-Pro-Display-Bold' : 'SF-Pro-Display-Medium';

    return <Button
      key={`${name}_${page}`}
      accessible={true}
      accessibilityLabel={name}
      accessibilityTraits='button'
      onPress={() => onPressHandler(page)}
      onLayout={onLayoutHandler}
    >
      <View style={[styles.tab, this.props.tabStyle, ]}>
        <MyText style={[{color: textColor, fontFamily, }, textStyle, ]}>
          {name}
        </MyText>
      </View>
    </Button>;
  },

  measureTab(page, event) {
    const { x, width, height, } = event.nativeEvent.layout;
    this._tabsMeasurements[page] = {left: x, right: x + width, width, height, };
    this.updateView({value: this.props.scrollValue.__getValue(), });
  },

  render() {
    const { team, teamImage, lastGame, navigation, roster } = this.props;
    const tabUnderlineStyle = {
      position: 'absolute',
      height: 4,
      backgroundColor: 'navy',
      bottom: 0,
    };

    const shadowOpt = {
			width:80,
			height:80,
			color:team.primaryColor,
			border:8,
			radius:3,
			opacity:0.2,
			x:0,
			y:3,
			// style:{marginVertical:5}
		}

    const dynamicTabUnderline = {
      left: this.state._leftTabUnderline,
      width: this.state._widthTabUnderline,
    };
    
    return <Animated.View
      style={[styles.container, {backgroundColor: this.props.backgroundColor, }, this.props.style, ]}
      onLayout={this.onContainerLayout}
    >
      <Animated.View style={[styles.headerContainer, this.props.headerStyle]}>
          <View style={styles.teamInfoContainer}>
            <BoxShadow setting={shadowOpt}>
              <View style={[styles.teamImageContainer, { backgroundColor: team.primaryColor }]}>
                <Image style={[styles.teamImage]} source={teamImage}/>
              </View>
            </BoxShadow>
              <View style={styles.teamDetails}>
                <MyText weight={500} style={styles.teamSubName}>42 - 20</MyText>
                <MyText weight={700} style={styles.teamName}>{team.fullName}</MyText>
                <MyText weight={500} style={styles.teamSubName}>{`${team.confName}ern`}, {team.divName}</MyText>
              </View>
          </View>
          {
            lastGame ? 
              <Collapsible
                  style={{paddingVertical: 0, marginTop: 5}}
                  nav={navigation}
                  date={20190404}
                  status={lastGame.statusNum}
                  hTeam={lastGame.hTeam}
                  vTeam={lastGame.vTeam}
                  hTeamScore={{ score: lastGame.hTeamScore}}
                  vTeamScore={{ score: lastGame.vTeamScore}}
                  hTeamImage={lastGame.hTeamImage}
                  vTeamImage={lastGame.vTeamImage}
                  hTeamIsWinner={false}
                  gameTime={'FINAL'}
                  gameId={123}
                  nugget={''}
                  clock={''}
                  isCollapsible={false}
                  period={4}
                />
            : 
            <Placeholder
                Animation={Fade}>
                    <PlaceholderLine width={80} style={{ backgroundColor: 'black' }}/>
                    <PlaceholderLine style={{ backgroundColor: 'black' }}/>
                    <PlaceholderLine width={30} style={{ backgroundColor: 'black' }}/>
            </Placeholder>
          }
      </Animated.View>
      <ScrollView
        ref={(scrollView) => { this._scrollView = scrollView; }}
        horizontal={true}
        showsHorizontalScrollIndicator={false}
        showsVerticalScrollIndicator={false}
        directionalLockEnabled={true}
        bounces={false}
        scrollsToTop={false}
      >
        <View
          style={[styles.tabs, {width: this.state._containerWidth, }, this.props.tabsContainerStyle, ]}
          ref={'tabContainer'}
          onLayout={this.onTabContainerLayout}
        >
          {this.props.tabs.map((name, page) => {
            const isTabActive = this.props.activeTab === page;
            const renderTab = this.props.renderTab || this.renderTab;
            return renderTab(name, page, isTabActive, this.props.goToPage, this.measureTab.bind(this, page));
          })}
          <Animated.View style={[tabUnderlineStyle, dynamicTabUnderline, this.props.underlineStyle, ]} />
        </View>
      </ScrollView>
    </Animated.View>;
  },

  componentWillReceiveProps(nextProps) {
    // If the tabs change, force the width of the tabs container to be recalculated
    if (JSON.stringify(this.props.tabs) !== JSON.stringify(nextProps.tabs) && this.state._containerWidth) {
      this.setState({ _containerWidth: null, });
    }
  },

  onTabContainerLayout(e) {
    this._tabContainerMeasurements = e.nativeEvent.layout;
    let width = this._tabContainerMeasurements.width;
    if (width < WINDOW_WIDTH) {
      width = WINDOW_WIDTH;
    }
    this.setState({ _containerWidth: width, });
    this.updateView({value: this.props.scrollValue.__getValue(), });
  },

  onContainerLayout(e) {
    const { height } = e.nativeEvent.layout;
    this.props.updateHeight(height);
    reactotron.display({name: 'tab height', value: height});
    this._containerMeasurements = e.nativeEvent.layout;
    this.updateView({value: this.props.scrollValue.__getValue(), });
  },
});

module.exports = ScrollableTabBar;

const styles = StyleSheet.create({
  tab: {
      height: 49,
      alignItems: 'center',
      justifyContent: 'center',
      paddingLeft: 10,
      paddingRight: 10,
  },
  container: {
      position:'absolute',
      zIndex: 10,
      elevation: 9,
      height: 211.3
  },
  tabs: {
      flexDirection: 'row',
      justifyContent: 'center',
  },
  headerContainer: {
    paddingHorizontal: 20,
    backgroundColor: theme.cardBgColor
  },
  headerText: {
      color: 'white',
  },
  teamInfoContainer: {
      flexDirection: 'row', 
      paddingVertical: 10,
  },
  teamImageContainer: {
      justifyContent: 'center',
      height: 80,
      width: 80,
      borderRadius: 10,
  },
  teamImage: {
      elevation: 8,
      height: 80,
      width: 80,
      resizeMode: 'contain',
  },
  teamDetails: {
      marginLeft: 15,
      paddingBottom: 5,
      height: 80,
      justifyContent: 'flex-end'
  },
  teamName: {
      letterSpacing: 0.5,
      color: 'white',
      fontSize: 24,
  },
  teamSubName: {
      fontSize: 13,
      color: '#ccc'
  },
  sectionTitle: {
      paddingVertical: 10,
      paddingLeft: 5,
      fontSize: 14,
      color: '#fff'
  },
  playerImageContainer: {
    width: 30,
    height: 30, 
    borderRadius: 20, 
    backgroundColor: '#333', 
    justifyContent: 'center',
    marginRight: -10,
    borderWidth: 2,
    borderColor: '#222'
  },
  playerImage: {
    height: 25, 
    width: 25, 
    borderRadius: 20
  },
  teamNameHeader: {
    zIndex: 3,
    fontSize: 22, 
    color: 'white', 
    alignSelf: 'flex-start',
    fontFamily: 'SF-Pro-Display-Bold',
    position: 'absolute',
    left: 20,
    top: 0
  }
});
