const React = require('react');
const { ViewPropTypes } = ReactNative = require('react-native');
const PropTypes = require('prop-types');
const createReactClass = require('create-react-class');
import * as theme from './../../Theme';
import * as Animatable from 'react-native-animatable';
import MyText from './../../components/MyText/MyText';
import Collapsible from '../../components/Collapsible/Collapsible';
import * as api from './../../api/data_nba_endpoints';
import { BoxShadow } from 'react-native-shadow';
import {
    Placeholder,
    PlaceholderMedia,
    PlaceholderLine,
    Fade
} from "rn-placeholder";
import reactotron from 'reactotron-react-native';
const {
  View,
  Animated,
  StyleSheet,
  ScrollView,
  Text,
  Platform,
  Dimensions,
  Image,
  TouchableOpacity
} = ReactNative;
const Button = require('./Button');

const WINDOW_WIDTH = Dimensions.get('window').width;

const ScrollableTabBar = createReactClass({
  propTypes: {
    goToPage: PropTypes.func,
    activeTab: PropTypes.number,
    tabs: PropTypes.array,
    backgroundColor: PropTypes.string,
    activeTextColor: PropTypes.string,
    inactiveTextColor: PropTypes.string,
    scrollOffset: PropTypes.number,
    style: ViewPropTypes.style,
    tabStyle: ViewPropTypes.style,
    tabsContainerStyle: ViewPropTypes.style,
    textStyle: Text.propTypes.style,
    renderTab: PropTypes.func,
    underlineStyle: ViewPropTypes.style,
    onScroll: PropTypes.func,
    updateHeight: PropTypes.func,
  },

  getDefaultProps() {
    return {
      scrollOffset: 52,
      activeTextColor: 'navy',
      inactiveTextColor: 'black',
      backgroundColor: null,
      style: {},
      tabStyle: {},
      tabsContainerStyle: {},
      underlineStyle: {},
    };
  },

  getInitialState() {
    this._tabsMeasurements = [];
    return {
      _leftTabUnderline: new Animated.Value(0),
      _widthTabUnderline: new Animated.Value(0),
      _containerWidth: null,
    };
  },

  componentDidMount() {
    this.props.scrollValue.addListener(this.updateView);
  },

  updateView(offset) {
    const position = Math.floor(offset.value);
    const pageOffset = offset.value % 1;
    const tabCount = this.props.tabs.length;
    const lastTabPosition = tabCount - 1;

    if (tabCount === 0 || offset.value < 0 || offset.value > lastTabPosition) {
      return;
    }

    if (this.necessarilyMeasurementsCompleted(position, position === lastTabPosition)) {
      this.updateTabPanel(position, pageOffset);
      this.updateTabUnderline(position, pageOffset, tabCount);
    }
  },

  necessarilyMeasurementsCompleted(position, isLastTab) {
    return this._tabsMeasurements[position] &&
      (isLastTab || this._tabsMeasurements[position + 1]) &&
      this._tabContainerMeasurements &&
      this._containerMeasurements;
  },

  updateTabPanel(position, pageOffset) {
    const containerWidth = this._containerMeasurements.width;
    const tabWidth = this._tabsMeasurements[position].width;
    const nextTabMeasurements = this._tabsMeasurements[position + 1];
    const nextTabWidth = nextTabMeasurements && nextTabMeasurements.width || 0;
    const tabOffset = this._tabsMeasurements[position].left;
    const absolutePageOffset = pageOffset * tabWidth;
    let newScrollX = tabOffset + absolutePageOffset;

    // center tab and smooth tab change (for when tabWidth changes a lot between two tabs)
    newScrollX -= (containerWidth - (1 - pageOffset) * tabWidth - pageOffset * nextTabWidth) / 2;
    newScrollX = newScrollX >= 0 ? newScrollX : 0;

    if (Platform.OS === 'android') {
      this._scrollView.scrollTo({x: newScrollX, y: 0, animated: false, });
    } else {
      const rightBoundScroll = this._tabContainerMeasurements.width - (this._containerMeasurements.width);
      newScrollX = newScrollX > rightBoundScroll ? rightBoundScroll : newScrollX;
      this._scrollView.scrollTo({x: newScrollX, y: 0, animated: false, });
    }

  },

  updateTabUnderline(position, pageOffset, tabCount) {
    const lineLeft = this._tabsMeasurements[position].left;
    const lineRight = this._tabsMeasurements[position].right;

    if (position < tabCount - 1) {
      const nextTabLeft = this._tabsMeasurements[position + 1].left;
      const nextTabRight = this._tabsMeasurements[position + 1].right;

      const newLineLeft = (pageOffset * nextTabLeft + (1 - pageOffset) * lineLeft);
      const newLineRight = (pageOffset * nextTabRight + (1 - pageOffset) * lineRight);

      this.state._leftTabUnderline.setValue(newLineLeft);
      this.state._widthTabUnderline.setValue(newLineRight - newLineLeft);
    } else {
      this.state._leftTabUnderline.setValue(lineLeft);
      this.state._widthTabUnderline.setValue(lineRight - lineLeft);
    }
  },

  renderTab(name, page, isTabActive, onPressHandler, onLayoutHandler) {
    const { activeTextColor, inactiveTextColor, textStyle, } = this.props;
    const textColor = isTabActive ? activeTextColor : inactiveTextColor;
    // const fontWeight = isTabActive ? 'bold' : 'normal';
    const fontFamily = isTabActive ? 'SF-Pro-Display-Bold' : 'SF-Pro-Display-Medium';

    return <Button
      key={`${name}_${page}`}
      accessible={true}
      accessibilityLabel={name}
      accessibilityTraits='button'
      onPress={() => onPressHandler(page)}
      onLayout={onLayoutHandler}
    >
      <View style={[styles.tab, this.props.tabStyle, ]}>
        <MyText style={[{color: textColor, fontFamily, }, textStyle, ]}>
          {name}
        </MyText>
      </View>
    </Button>;
  },

  measureTab(page, event) {
    const { x, width, height, } = event.nativeEvent.layout;
    this._tabsMeasurements[page] = {left: x, right: x + width, width, height, };
    this.updateView({value: this.props.scrollValue.__getValue(), });
  },

  render() {
    const { hTeam, vTeam, hTeamImage, vTeamImage, hTeamScore, vTeamScore, clock, period } = this.props;
    const tabUnderlineStyle = {
      position: 'absolute',
      height: 4,
      backgroundColor: 'navy',
      bottom: 0,
    };

    const dynamicTabUnderline = {
      left: this.state._leftTabUnderline,
      width: this.state._widthTabUnderline,
    };
    
    return <Animated.View
      style={[styles.container, {backgroundColor: this.props.backgroundColor, }, this.props.style, ]}
      onLayout={this.onContainerLayout}
    >
      <Animated.View style={[styles.headerContainer, this.props.headerStyle]}>
        <TouchableOpacity onPress={() => this.props.handleNavigation(false)} style={styles.teamInfoContainer}>
          <Image source={vTeamImage} style={styles.teamImage}/>
          <MyText weight={700} style={styles.teamName}>{vTeam.nickname}</MyText>
          <MyText style={styles.teamStanding}>({vTeamScore.win} - {vTeamScore.loss})</MyText>
        </TouchableOpacity>
        <View style={[styles.teamInfoContainer, { flex: 1.5, marginTop: -30 }]}>
          <View style={[styles.teamInfoContainer, { flexDirection: 'row' }]}>
            <View style={styles.scoreContainer}>
              <MyText weight={500} style={styles.score}>{vTeamScore.score}</MyText>
            </View>
            <MyText weight={500} style={styles.scoreDivider}>:</MyText>
            <View style={styles.scoreContainer}>
              <MyText weight={500} style={styles.score}>{hTeamScore.score}</MyText>
            </View>
          </View>
          <MyText style={styles.clock}>Q4 {clock}</MyText>
        </View>
        {/* <View style={[styles.teamInfoContainer, { flex: 1.5 }]}>
          <MyText style={styles.clock}>Q4 {clock}</MyText>
          <MyText weight={700} style={styles.score}>{vTeamScore.score}   :   {hTeamScore.score}</MyText>
          <MyText weight={700} style={{ borderRadius: 3, marginTop: 10, paddingVertical: 1, paddingHorizontal: 8,  color: 'white', backgroundColor: '#C01E2F' }}>LIVE</MyText>
        </View> */}
        <TouchableOpacity onPress={() => this.props.handleNavigation(true)} style={styles.teamInfoContainer}>
          <Image source={hTeamImage} style={styles.teamImage}/>
          <MyText weight={700} style={styles.teamName}>{hTeam.nickname}</MyText>
          <MyText style={styles.teamStanding}>({hTeamScore.win} - {hTeamScore.loss})</MyText>
        </TouchableOpacity>
      </Animated.View>
      <ScrollView
        ref={(scrollView) => { this._scrollView = scrollView; }}
        horizontal={true}
        showsHorizontalScrollIndicator={false}
        showsVerticalScrollIndicator={false}
        directionalLockEnabled={true}
        bounces={false}
        scrollsToTop={false}
      >
        <View
          style={[styles.tabs, {width: this.state._containerWidth, }, this.props.tabsContainerStyle, ]}
          ref={'tabContainer'}
          onLayout={this.onTabContainerLayout}
        >
          {this.props.tabs.map((name, page) => {
            const isTabActive = this.props.activeTab === page;
            const renderTab = this.props.renderTab || this.renderTab;
            return renderTab(name, page, isTabActive, this.props.goToPage, this.measureTab.bind(this, page));
          })}
          <Animated.View style={[tabUnderlineStyle, dynamicTabUnderline, this.props.underlineStyle, ]} />
        </View>
      </ScrollView>
    </Animated.View>;
  },

  componentWillReceiveProps(nextProps) {
    // If the tabs change, force the width of the tabs container to be recalculated
    if (JSON.stringify(this.props.tabs) !== JSON.stringify(nextProps.tabs) && this.state._containerWidth) {
      this.setState({ _containerWidth: null, });
    }
  },

  onTabContainerLayout(e) {
    this._tabContainerMeasurements = e.nativeEvent.layout;
    let width = this._tabContainerMeasurements.width;
    if (width < WINDOW_WIDTH) {
      width = WINDOW_WIDTH;
    }
    this.setState({ _containerWidth: width, });
    this.updateView({value: this.props.scrollValue.__getValue(), });
  },

  onContainerLayout(e) {
    const { height } = e.nativeEvent.layout;
    this.props.setHeaderHeight(height);
    reactotron.display({name: 'tab height', value: height});
    this._containerMeasurements = e.nativeEvent.layout;
    this.updateView({value: this.props.scrollValue.__getValue(), });
  },
});

module.exports = ScrollableTabBar;

const styles = StyleSheet.create({
  tab: {
      height: 49,
      alignItems: 'center',
      justifyContent: 'center',
      paddingLeft: 10,
      paddingRight: 10,
  },
  container: {
      position:'absolute',
      zIndex: 10,
      elevation: 9,
      height: 163.63636779785156
  },
  tabs: {
      flexDirection: 'row',
      justifyContent: 'center',
  },
  headerContainer: {
    paddingHorizontal: 10,
    flexDirection: 'row',
    backgroundColor: theme.cardBgColor
  },
  teamInfoContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  teamImage: {
    height: 80,
    width: 80,
  },
  teamName: {
    marginTop: -5,
    color: 'white',
    fontSize: 15
  },
  clock: {
    color: 'white',
    fontSize: 15,
    textAlign: 'center',
    position: 'absolute',
    bottom: 20
  },
  score: {
    color: 'white', 
    fontSize: 28, 
    textAlign: 'center'
  },
  teamStanding: {
    color: 'gray'
  },
  scoreContainer: {
    backgroundColor: '#2a2a2a', 
    paddingVertical: 3, 
    paddingHorizontal: 10, 
    borderRadius: 4, 
    justifyContent: 'center', 
    alignContent: 'center', 
    marginHorizontal: 5
  },
  scoreDivider: {
    color: 'gray', 
    fontSize: 28
  }
});
